intTem<-internet%>%dplyr::select(Temperatura)%>%mutate(temperatura=ifelse(Temperatura>40,NA,Temperatura))
#- Autos: | es o
intAut<-internet%>%dplyr::select(Autos)%>%mutate(autos=ifelse(Autos>200|Autos<0,NA,Autos))
#- Edad
intEd<-internet %>%dplyr::select(Edad)%>%mutate(edad=ifelse(Edad>100|Edad<5,NA,Edad))
#- Uso
intUso<-internet%>%dplyr::select(Uso)%>%mutate(uso=ifelse(Uso<0,NA,Uso))
#- Sitio
intSit<-internet%>%dplyr::select(Sitio)%>%mutate(sitio=ifelse(Sitio>7,NA,Sitio))
#- Para eliminarlas
#internet_sin_na <- na.omit(internet)
#- Calculamos la media de edad y la mediana de edad, con na.rm = TRUE nos omite para el calculo los valores nulos
intEd%>%summarise(Media=mean(edad,na.rm=TRUE),Mediana=median(edad,na.rm=TRUE))
#- Si la media es muy parecida a la mediana se dice que la variable es simetrica
#- Si no lo son, esto quiere decir que la media esta traccionada por algun punto o conjunto de puntos
intAut%>%summarise(Media=mean(autos,na.rm=TRUE),Mediana=median(autos,na.rm=TRUE))
intUso%>%summarise(Media=mean(uso,na.rm=TRUE),Mediana=median(uso,na.rm=TRUE))
intTem%>%summarise(Media=mean(temperatura,na.rm=TRUE),Mediana=median(temperatura,na.rm=TRUE))
#- Tomamos de la variable temperatura
intTem%>%ggplot()+geom_boxplot(aes(y=temperatura),fill="aquamarine3")+
theme_bw() #- Pone el fondo blanco
intUso%>%ggplot()+geom_boxplot(aes(y=uso),fill="coral3")+theme_bw()
#- No se pueden observar visualmente si son outliers moderados o severos
#- Calculamos las desviaciones -------------------------------------
#- Primer cuartil
Q1_uso<-summary(intUso$uso)[2]
#- Otra forma de sacarlo
#quantile(intUso$uso, na.rm = TRUE)[2]
#- Tercer cuartil
Q3_uso<-summary(intUso$uso)[5]
#- Rango intercuartil
DI_uso=Q3_uso-Q1_uso
#- Q1 - 1.5 del RI (sacamos limite inferior)
VAI_uso<-Q1_uso-1.5*DI_uso
#- Me da negativo, fuera de rango
#- Q3 + 1.5 del RI (sacamos el limite superior)
VAS_uso<-Q3_uso+1.5*DI_uso
#- 309 horas
#- Q3 + 3 del RI (limite superior para outliers extremos)
VLS_uso<-Q3_uso+3*DI_uso
#- Q1 - 3 del RI (limite inferior outliers extremos)
VLI_uso<-Q1_uso-3*DI_uso
#- Row Bind juntamos todas
rbind(DI_uso,VAS_uso,VAI_uso,VLI_uso,VLS_uso)
#- Solamente tenemos outliers sobre el limite superior entre 1.5 y 3 RI
which(intUso$uso>VAS_uso)
which(intUso$uso<VAI_uso)
which(intUso$uso>VAS_uso&intUso$uso>VLS_uso)
which(intUso$uso<VAI_uso&intUso$uso<VLI_uso)
#- Integer(0) significa que estas obteniendo un vector de enterios vacios. Es un vector que no contiene elemenos
#- Al final de este tp 1  tenemos una funcion creada casera para deteccion de outliers
#- Otros paquetes para la deteccion de outliers:
#- outliers
#- outlierDetection
#- robustbase
#- Leemos la base de datos
gorriones <- read_excel("C:/Users/peton/Documents/Maestría CD/Análisis Inteligente de Datos/Clase 1/Gorriones.xlsx")
#- Conjunto de gorrione con sus medidas fisicas, luego de un derrame de petroleo se quiere registrar si sobrevivieron los mas grandes
#- Los mas chicos etc.
#- Ver como esta almacenada cada variable
gorriones$pajaro%>%class()
gorriones$largototal%>%class()
gorriones$extension%>%class()
gorriones$cabeza%>%class()
gorriones$humero%>%class()
gorriones$esternon%>%class()
gorriones$sobrevida%>%class()
#Confeccionar un informe para cada variable( univariado).
gorriones%>%str() # nos muestra que hay en cada variable
gorriones%>%select(largototal:esternon)%>% summary() # nos hace un resumen para cada variable
sobrev=as.factor(gorriones$sobrevida)
View(dj1)
View(plot1)
knitr::opts_chunk$set(echo = TRUE)
summary(intUso$uso)[2]
Q1_uso<-summary(intUso$uso)[2]
#- Calculamos las desviaciones -------------------------------------
#- Primer cuartil
Q1_uso<-summary(intUso$uso)[2]
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
#Cargamos las librerías
library(readxl)#lectura
library(dplyr) #manipulacion de datos
library(kableExtra) #tablas
library(ggplot2) #graficos
library(tidyverse) #manipulacion de datos
library(ggpubr) #para juntar
library(ggforce) # grafico de violin y jitter
library(GGally) # ggpairs
library(corrplot) # para correlogramas
#leemos los datos
recepcionistas <- read_excel("C:/Users/peton/Documents/Maestría CD/Análisis Inteligente de Datos/Clase 1/recepcionistas.xls")
recepcionistas
#separamos  las puntuaciones por juez
juez1=recepcionistas[,2:4]
juez2=recepcionistas[,5:7]
#calculamos los promedios por candidato para cada juez
prom_j1=apply(juez1,1,mean)
prom_j2=apply(juez2,1,mean)
prom_j1
prom_j2
#buscamos el máximo promedio por juez y vemos a quien corresponde
cand=recepcionistas%>%dplyr::select(candidatos)%>%unlist()
max_j1=cand[which.max(prom_j1)]
max_j1
max_j2=cand[which.max(prom_j2)]
max_j2
#coinciden los máximos?
#(b) Calcule el promedio de cada una de las aspirantes tomando en cuenta todos los rubros y ambos jueces.
puntuaciones=select(recepcionistas,'cord.juez 1':idiom.juez2)
promxcand=data.frame("Cand"=cand,"Prom"=round(apply(puntuaciones,1,mean),2))
#Eliminar index
rownames(promxcand)<-NULL
promxcand
#(c) Transformar las puntuaciones observadas de modo tal que cada una de las seis variables tenga media 0 y dispersión 1. ¿Cuál sería el objetivo de esta transformación?
#estandarizamos por columna
punt_stand=data.frame(puntuaciones%>%scale())
punt_stand$Candidatas = recepcionistas$candidatos
#queremos hacer comparables las diferentes puntuaciones
#(d) Transformar las puntuaciones de modo tal que cada candidata tenga para cada juez media 0 y dispersión 1. ¿Cuál sería el objetivo de esta transformación?
sal2=data.frame(cand,t(t(juez1)%>%scale()%>%round(2)))
#Sacamos el row index
rownames(sal2)<-NULL
sal2 %>%
kbl(caption = "Puntuaciones Estandarizadas Juez 1") %>%
kable_classic(full_width = F, html_font = "Cambria")
sal3=data.frame(cand,t(t(juez2)%>%scale()%>%round(2)))
rownames(sal3)<-NULL
sal3 %>%
kbl(caption = "Puntuaciones Estandarizadas Juez 2") %>%
kable_classic(full_width = F, html_font = "Cambria")
#(e) Grafique los perfiles multivariados de cada una de las candidatas para ambas transformaciones. ¿Qué observa?
#damos nueva forma a los datos del juez 1
dj1= gather(sal2, key="rubro", value="valor", cord.juez.1:idiom.juez1)
#Pasamos a factor ambas variables
RUBRO=as.factor(dj1$rubro)
Candi=as.factor(dj1$cand)
#Generamos el plot y lo almacenamos en una variable
plot1=ggplot(dj1,aes(x=RUBRO,y=valor))+geom_line(aes(x=RUBRO,y=valor,group =Candi,color=Candi))+ labs(title = "juez 1") +
theme(axis.text.x  = element_text(angle=90))
#damos nueva forma a los datos del juez 2
dj2= gather(sal3, key="rubro", value="valor", cord.juez.2:idiom.juez2)
dj2
Rubro=as.factor(dj2$rubro)
Candi=as.factor(dj2$cand)
plot2=ggplot(dj2,aes(x=Rubro,y=valor))+geom_line(aes(x=Rubro,y=valor,group =Candi,color=Candi))+ labs(title = "juez 2")+theme(axis.text.x  = element_text(angle=90))
ggarrange(plot1,plot2)
#- Leemos el archivo
internet <- read_excel("C:/Users/peton/Documents/Maestría CD/Análisis Inteligente de Datos/Clase 3/Internet2013.xls")
#- Veamos un poco los datos
summary(internet)
#- Que pueden ver con el summary?
#names(internet)
#- Vamos a agrupar por Nacionalidad
grafica <- ggparcoord(internet, columns=c(3,5,7:10), groupColumn="Nacionalidad")
grafica+theme_bw()
#- Otro ejemplo agrupando por uso
grafica1 <- ggparcoord(internet, columns=c(3,5,7:10), groupColumn="Uso")
grafica1+theme_bw()
#- Muy poco se puede ver por ejemplo el punto alto de autos y no mucho mas
#- No se puede visualizar correctamente porque el grafico de coordenadas paralelas esta diseñado para ver como maximo 3 grupos
#- Hacemos el table
internet %>% dplyr::select(Sexo)%>%table()
#- Tal vez se podria, si hay relaciones importantes entre las variables, imputarla en base a otros valores.
#- dplyr:: para hacer referencia a una funcion o un paquete especifico
internet%>%dplyr::select(Edad)%>%arrange(-Edad)
internet%>%dplyr::select(Edad)%>%arrange(Edad)
internet%>%dplyr::select(Edad)%>%summary()
#- Errores de carga
#- Hacemos el table de frequencia para sitio
internet%>%dplyr::select(Sitio)%>%table()
#- Es posible que el 8 sea un 7 y el 28 sea un 2
#- Si no tengo manera de sacarlo los puedo imputar como na y luego ver que hacemos
#- Tabla de frecuencia de cigarrillos
internet%>%dplyr::select(Cigarrillos)%>%arrange(-Cigarrillos)
internet%>%dplyr::select(Cigarrillos)%>%summary()
#- Valor alto (100) pero no podemos saberlo
#- Tabla de frecuencias para Autos
internet%>%dplyr::select(Nacionalidad,Autos)%>%arrange(-Autos)
#- Tabla de frecuencia de temperaturas
internet%>%dplyr::select(Nacionalidad,Temperatura)%>%arrange(Temperatura)
#- Seleccionamos temperatura de la base de datos Internet, mutate para crear una nueva variable temperatura (en minuscula)
#- Si es mayor a 40 lo reemplazamos con NA (Not Available), esto es para luego eliminarlo con el na.omit
intTem<-internet%>%dplyr::select(Temperatura)%>%mutate(temperatura=ifelse(Temperatura>40,NA,Temperatura))
#- Autos: | es o
intAut<-internet%>%dplyr::select(Autos)%>%mutate(autos=ifelse(Autos>200|Autos<0,NA,Autos))
#- Edad
intEd<-internet %>%dplyr::select(Edad)%>%mutate(edad=ifelse(Edad>100|Edad<5,NA,Edad))
#- Uso
intUso<-internet%>%dplyr::select(Uso)%>%mutate(uso=ifelse(Uso<0,NA,Uso))
#- Sitio
intSit<-internet%>%dplyr::select(Sitio)%>%mutate(sitio=ifelse(Sitio>7,NA,Sitio))
#- Para eliminarlas
#internet_sin_na <- na.omit(internet)
#- Calculamos la media de edad y la mediana de edad, con na.rm = TRUE nos omite para el calculo los valores nulos
intEd%>%summarise(Media=mean(edad,na.rm=TRUE),Mediana=median(edad,na.rm=TRUE))
#- Si la media es muy parecida a la mediana se dice que la variable es simetrica
#- Si no lo son, esto quiere decir que la media esta traccionada por algun punto o conjunto de puntos
intAut%>%summarise(Media=mean(autos,na.rm=TRUE),Mediana=median(autos,na.rm=TRUE))
intUso%>%summarise(Media=mean(uso,na.rm=TRUE),Mediana=median(uso,na.rm=TRUE))
intTem%>%summarise(Media=mean(temperatura,na.rm=TRUE),Mediana=median(temperatura,na.rm=TRUE))
#- Tomamos de la variable temperatura
intTem%>%ggplot()+geom_boxplot(aes(y=temperatura),fill="aquamarine3")+
theme_bw() #- Pone el fondo blanco
intUso%>%ggplot()+geom_boxplot(aes(y=uso),fill="coral3")+theme_bw()
#- No se pueden observar visualmente si son outliers moderados o severos
View(intUso)
summary(intUso$uso)
DI_uso=Q3_uso-Q1_uso
#- Primer cuartil
Q1_uso<-summary(intUso$uso)[2]
#- Otra forma de sacarlo
#quantile(intUso$uso, na.rm = TRUE)[2]
#- Tercer cuartil
Q3_uso<-summary(intUso$uso)[5]
DI_uso=Q3_uso-Q1_uso
DI_uso
Q1_uso
VAI_uso<-Q1_uso-1.5*DI_uso
VAI_uso
VAS_uso<-Q3_uso+1.5*DI_uso
VAS_uso
rbind(DI_uso,VAS_uso,VAI_uso,VLI_uso,VLS_uso)
Q1_uso<-summary(intUso$uso)[2]
#- Otra forma de sacarlo
#quantile(intUso$uso, na.rm = TRUE)[2]
#- Tercer cuartil
Q3_uso<-summary(intUso$uso)[5]
#- Rango intercuartil
DI_uso=Q3_uso-Q1_uso
#- Q1 - 1.5 del RI (sacamos limite inferior)
VAI_uso<-Q1_uso-1.5*DI_uso
#- Me da negativo, fuera de rango
#- Q3 + 1.5 del RI (sacamos el limite superior)
VAS_uso<-Q3_uso+1.5*DI_uso
#- 309 horas
#- Q3 + 3 del RI (limite superior para outliers extremos)
VLS_uso<-Q3_uso+3*DI_uso
#- Q1 - 3 del RI (limite inferior outliers extremos)
VLI_uso<-Q1_uso-3*DI_uso
rbind(DI_uso,VAS_uso,VAI_uso,VLI_uso,VLS_uso)
which(intUso$uso>VAS_uso)
which(intUso$uso<VAI_uso)
which(intUso$uso>VAS_uso&intUso$uso>VLS_uso)
which(intUso$uso<VAI_uso&intUso$uso<VLI_uso)
#- Leemos la base de datos
gorriones <- read_excel("C:/Users/peton/Documents/Maestría CD/Análisis Inteligente de Datos/Clase 1/Gorriones.xlsx")
#- Conjunto de gorrione con sus medidas fisicas, luego de un derrame de petroleo se quiere registrar si sobrevivieron los mas grandes
#- Los mas chicos etc.
View(gorriones)
#- Ver como esta almacenada cada variable
gorriones$pajaro%>%class()
gorriones$largototal%>%class()
gorriones$extension%>%class()
gorriones$cabeza%>%class()
gorriones$humero%>%class()
gorriones$esternon%>%class()
gorriones$sobrevida%>%class()
#Confeccionar un informe para cada variable( univariado).
gorriones%>%str() # nos muestra que hay en cada variable
#Confeccionar un informe para cada variable( univariado).
gorriones%>%glimpse() # nos muestra que hay en cada variable
gorriones%>%select(largototal:esternon)%>% summary() # nos hace un resumen para cada variable
sobrev=as.factor(gorriones$sobrevida)
ggplot(gorriones) +
geom_histogram(bins = 10, aes(x = largototal, fill = factor(sobrevida)), color = 'black') + facet_grid(sobrevida~., scales = 'free') +
xlab("largo total") +
ylab("Frecuencia") +
ggtitle("Distribución de la variable Largo Total para los distintos Sobrevida") +
theme_minimal()
ggplot(gorriones) +
geom_histogram(bins = 5, aes(x = largototal, fill = factor(sobrevida)), color = 'black') + facet_grid(sobrevida~., scales = 'free') +
xlab("largo total") +
ylab("Frecuencia") +
ggtitle("Distribución de la variable Largo Total para los distintos Sobrevida") +
theme_minimal()
ggplot(gorriones) +
geom_histogram(bins = 16, aes(x = largototal, fill = factor(sobrevida)), color = 'black') + facet_grid(sobrevida~., scales = 'free') +
xlab("largo total") +
ylab("Frecuencia") +
ggtitle("Distribución de la variable Largo Total para los distintos Sobrevida") +
theme_minimal()
ggplot(gorriones) +
geom_histogram(bins = 100, aes(x = largototal, fill = factor(sobrevida)), color = 'black') + facet_grid(sobrevida~., scales = 'free') +
xlab("largo total") +
ylab("Frecuencia") +
ggtitle("Distribución de la variable Largo Total para los distintos Sobrevida") +
theme_minimal()
ggplot(gorriones) +
geom_histogram(bins = 16, aes(x = largototal, fill = factor(sobrevida)), color = 'black') + facet_grid(sobrevida~., scales = 'free') +
xlab("largo total") +
ylab("Frecuencia") +
ggtitle("Distribución de la variable Largo Total para los distintos Sobrevida") +
theme_minimal()
ggplot(gorriones) +
geom_density( aes(x = cabeza, fill = factor(sobrevida)), color = 'black') + facet_grid(sobrevida~., scales = 'free') +
xlab("cabeza") + xlim(c(30,35))+
ylab("Frecuencia") +
ggtitle("Distribución de la variable Cabeza para los distintos Sobrevida") +
theme_minimal()
ggplot(gorriones,aes(x=sobrev,y=largototal,fill=sobrev))+geom_boxplot(notch=TRUE)+
scale_fill_manual(values=c("#FE2E2E","#819FF7")) +# cambiamos los colores
xlab("Sobrevida")+ylab("Largo Total")
gorriones %>% ggplot(aes(x = sobrev,
y = cabeza)) +
geom_violin(trim = FALSE, aes(color = sobrev)) +
stat_summary(fun.data = "mean_sdl",
fun.args = list(mult = 1),
geom = "pointrange",
color = "black") +
scale_color_manual(values = c("#00AFBB", "#E7B800"))
gorriones %>%
ggplot(aes(x = sobrev,
y = humero)) +
geom_violin(aes(fill = sobrev), trim = FALSE) +
geom_boxplot(width = 0.15)+
scale_fill_manual(values = c( "#FC4E07","brown")) +
theme(legend.position = "none")
gorriones %>%
ggplot(aes(x = sobrev,
y = esternon)) +
geom_sina(aes(color = sobrev), size = 2)+
scale_color_manual(values = c( "purple", "#FC4E07")) +
theme(legend.position = "none")
g2 <- gorriones %>%
ggplot(aes(x=sobrev, y=extension, fill=sobrev)) +
geom_violin() +
theme(
legend.position="none",
plot.title = element_text(size=10, # tamaño
hjust = 0.5, # centrado
face="bold", # estilo
color = "black")
) +ylim(c(220,260))+
labs( x="sobrevida", y="Extensión",
title="Distribución de Extensión  por Supervivencia")+geom_boxplot(width = 0.3,fill="white")
g2
gorr=gorriones%>%select(largototal:esternon)
sobrev=factor(gorriones$sobrevida)
ggpairs(gorr, aes(color=sobrev),
upper = list(continuous = "density", combo = "box_no_facet"),
lower = list(continuous = "points" , combo ="dot_no_facet"))+
theme_bw()
M= cor(gorr)
corrplot.mixed(M, upper = "pie",
lower = "ellipse")
M= cor(gorr)
corrplot.mixed(M, upper = "ellipse",
lower = "scatter")
M= cor(gorr)
corrplot.mixed(M, upper = "ellipse",
lower = "shade")
src/rpart/z111_traintest_estratificado.r
cd labo2024v1
rm(list = ls()) # Borro todos los objetos
gc() # Garbage Collection
require("data.table")
require("rpart")
PARAM <- list()
PARAM$semilla <- 102191
#------------------------------------------------------------------------------
# particionar agrega una columna llamada fold a un dataset
#  que consiste en una particion estratificada segun agrupa
# particionar( data=dataset, division=c(70,30),
#  agrupa=clase_ternaria, seed=semilla)   crea una particion 70, 30
particionar <- function(
data, division, agrupa = "",
campo = "fold", start = 1, seed = NA) {
if (!is.na(seed)) set.seed(seed)
bloque <- unlist(mapply(function(x, y) {
rep(y, x)
}, division, seq(from = start, length.out = length(division))))
data[, (campo) := sample(rep(bloque, ceiling(.N / length(bloque))))[1:.N],
by = agrupa
]
}
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Aqui comienza el programa
# Aqui se debe poner la carpeta de la computadora local
# Establezco el Working Directory
setwd("X:\\gdrive\\austral2023r\\")
rm(list = ls()) # Borro todos los objetos
gc() # Garbage Collection
require("data.table")
require("rpart")
PARAM <- list()
PARAM$semilla <- 102191
#------------------------------------------------------------------------------
# particionar agrega una columna llamada fold a un dataset
#  que consiste en una particion estratificada segun agrupa
# particionar( data=dataset, division=c(70,30),
#  agrupa=clase_ternaria, seed=semilla)   crea una particion 70, 30
particionar <- function(
data, division, agrupa = "",
campo = "fold", start = 1, seed = NA) {
if (!is.na(seed)) set.seed(seed)
bloque <- unlist(mapply(function(x, y) {
rep(y, x)
}, division, seq(from = start, length.out = length(division))))
data[, (campo) := sample(rep(bloque, ceiling(.N / length(bloque))))[1:.N],
by = agrupa
]
}
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Aqui comienza el programa
# Aqui se debe poner la carpeta de la computadora local
# Establezco el Working Directory
setwd("C:\Users\peton\Documents\Maestría CD\Lab de Implementación I\datasets")
rm(list = ls()) # Borro todos los objetos
gc() # Garbage Collection
require("data.table")
require("rpart")
PARAM <- list()
PARAM$semilla <- 102191
#------------------------------------------------------------------------------
# particionar agrega una columna llamada fold a un dataset
#  que consiste en una particion estratificada segun agrupa
# particionar( data=dataset, division=c(70,30),
#  agrupa=clase_ternaria, seed=semilla)   crea una particion 70, 30
particionar <- function(
data, division, agrupa = "",
campo = "fold", start = 1, seed = NA) {
if (!is.na(seed)) set.seed(seed)
bloque <- unlist(mapply(function(x, y) {
rep(y, x)
}, division, seq(from = start, length.out = length(division))))
data[, (campo) := sample(rep(bloque, ceiling(.N / length(bloque))))[1:.N],
by = agrupa
]
}
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
# Aqui comienza el programa
# Aqui se debe poner la carpeta de la computadora local
# Establezco el Working Directory
setwd("C:/Users/peton/Documents/Maestría CD/Lab de Implementación I/datasets")
# cargo los datos
dataset <- fread("./datasets/dataset_pequeno.csv")
# cargo los datos
dataset <- fread("./datasets/dataset_pequeno")
# Aqui se debe poner la carpeta de la computadora local
# Establezco el Working Directory
setwd("C:/Users/peton/Documents/Maestría CD/Lab de Implementación I/datasets/")
rm(list = ls()) # Borro todos los objetos
gc() # Garbage Collection
require("data.table")
require("rpart")
PARAM <- list()
PARAM$semilla <- 102191
particionar <- function(
data, division, agrupa = "",
campo = "fold", start = 1, seed = NA) {
if (!is.na(seed)) set.seed(seed)
bloque <- unlist(mapply(function(x, y) {
rep(y, x)
}, division, seq(from = start, length.out = length(division))))
data[, (campo) := sample(rep(bloque, ceiling(.N / length(bloque))))[1:.N],
by = agrupa
]
}
setwd("C:/Users/peton/Documents/Maestría CD/Lab de Implementación I/datasets/")
# cargo los datos
dataset <- fread("./datasets/dataset_pequeno.csv")
setwd("C:/Users/peton/Documents/Maestría CD/Lab de Implementación I/datasets/")
dataset <- fread("./datasets/dataset_pequeno.csv")
dataset <- fread("C:/Users/peton/Documents/Maestría CD/Lab de Implementación I/datasets/dataset_pequeno.csv")
dataset <- dataset[clase_ternaria != ""]
# particiono estratificadamente el dataset
# Cambiar por la primer semilla de cada uno !
particionar(dataset, division = c(7, 3),
agrupa = "clase_ternaria", seed = PARAM$semilla) # aqui se usa SU semilla
param_basicos <- list(
"cp" = -1, # complejidad minima
"minsplit" = 400, # minima cantidad de regs en un nodo para hacer el split
"minbucket" = 10, # minima cantidad de regs en una hoja
"maxdepth" = 8 # profundidad máxima del arbol
)
# genero el modelo
# quiero predecir clase_ternaria a partir del resto
# fold==1  es training,  el 70% de los datos
modelo <- rpart("clase_ternaria ~ .",
data = dataset[fold == 1],
xval = 0,
control = param_basicos # aqui van los parametros
)
# aplico el modelo a los datos de testing
prediccion <- predict(modelo, # el modelo que genere recien
dataset[fold == 2], # fold==2  es testing, el 30% de los datos
type = "prob"
) # type= "prob"  es que devuelva la probabilidad
# prediccion es una matriz con TRES columnas,
#  llamadas "BAJA+1", "BAJA+2"  y "CONTINUA"
# cada columna es el vector de probabilidades
# agrego una columna que es la de las ganancias
dataset[, ganancia := ifelse(clase_ternaria == "BAJA+2", 117000, -3000)]
# para testing agrego la probabilidad
dataset[fold == 2, prob_baja2 := prediccion[, "BAJA+2"]]
# calculo la ganancia en testing  qu es fold==2
ganancia_test <- dataset[fold == 2 & prob_baja2 > 0.025, sum(ganancia)]
# escalo la ganancia como si fuera todo el dataset
ganancia_test_normalizada <- ganancia_test / 0.3
estimulos <- dataset[fold == 2 & prob_baja2 > 0.025, .N]
aciertos <- dataset[fold == 2 & prob_baja2 > 0.025 & clase_ternaria == "BAJA+2", .N]
cat("Testing total: ", dataset[fold == 2, .N], "\n")
cat("Testing BAJA+2: ", dataset[fold == 2 & clase_ternaria == "BAJA+2", .N], "\n")
cat("Estimulos: ", estimulos, "\n")
cat("Aciertos (BAJA+2): ", aciertos, "\n")
cat("Ganancia en testing (normalizada): ", ganancia_test_normalizada, "\n")
